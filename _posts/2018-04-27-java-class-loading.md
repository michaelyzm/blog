---
title: Java类加载流程
layout: post
date: 2018-04-27
categories: 架构
tags: [架构, 分析]
---
　　Java类加载流程是Java虚拟机的核心技术之一，同时也是安卓app实现热修复的关键技术，经过一段时间的学习，我有了下面这样一些心得。
### 为什么需要加载类
　　Java为什么需要加载类？这个问题对于纯Java程序员来说可能有点奇怪，但是对于传统的从C/C++开始接触编程，深刻了解CPU/内存运行机制的程序员来说，就是一个值得深究的问题了。传统的编译型语言，他们的编译和链接流程会把代码完整的转换成CPU能够识别的二进制文件，在运行时完整的加载到内存中。加载完了之后，不论是函数、结构体、联合体还是类，他们的结构就都已经在内存中了，全都存放在内存的代码区。  
　　但是Java不一样，Java程序运行时，并不是一口气把所有的代码全部加载到虚拟机内存的方法区，而是用到哪个类，才把哪个类加载进去。运行时没有用到过的类，就永远没有机会被加载到内存中。这样做有一个好处，就是方法区可以设置一个比较小的初始大小，只要加载的类总大小不超出内存大小，当前虚拟机就可以在不占用过多内存的前提下运行完成，而一旦当前方法区的容量不足以加载更多的类，还可以动态扩大方法区，保证程序正常运行。这样能够充分利用系统内存空间，在有限的内存中执行尽可能多的任务。那么当然也有它的缺点，随着程序的运行，越来越多的类会被加载到方法区中，而一旦方法区不够存放更多的类，也没有办法从方法区移除已加载的类，那么就会抛出OutOfMemoryError，导致程序运行失败。运行过程中的失败有可能比一开始运行就失败导致更加严重的问题。  
　　上面是从内存利用的角度解释了为什么要加载类，而从程序运行时的可扩展性的角度，能够给出一个更有说服力的理由，那就是Java可以在运行时指定加载某个事先只知道名字的类，这就Java语言开发的程序可以热修复的原理了。比如说我们开发一个App，在其中一个模块，我们只知道要加载一个名叫B的类进来，并且用它来构造界面。但是我们在开发时提供的B类可能有问题，到时App部署在线上之后不久就发生崩溃。这时，按照传统的方法，我们只能将App下架，或是退回到上一个版本，同时尽快修复bug，并且发布出去。那么已经被用户获得的App如果没有得到及时的更新，可能会一直运行带bug的版本，后果难以估量。如果我们采用热修复的方案，在开发App时，就仅仅指定类B的类名，并指定一个远程位置供类加载器获得类B，一旦线上的B类发生问题导致App崩溃，可以立刻开发一个带bug fix的B类到线上去替换老的B类，实现无需发布新版本即可修复已发布的应用。  
### 谁负责加载类
　　说了那么多动态加载类的好处，那么Java的类由谁负责加载呢？在大部分情况下，Java只需要依靠系统的类加载器即可。而系统类加载器包括以下三种：  
1. 启动类加载器（Bootstrap ClassLoader)    
也可称为引导类加载器。启动类加载器是用来加载虚拟机预定义的一系列类库的，它只会加载指定路径（由<JAVA_HOME>\lib和-Xbootclasspath所指定）下自己认识的类库文件。开发者无法直接使用该类库，若在ClassLoader中的getClassLoader()函数中返回null，系统会自动使用此类加载器寻找要加载的类。  
2. 扩展类加载器（Extension ClassLoader)  
扩展类加载器负责加载指定路径（由<JAVA_HOME>\lib\ext和java.ext.dirs所指定）下的所有类库文件。开发者可以直接使用这个类加载器。  
3. 应用程序类加载器（Application ClassLoader）  

由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径下所指定的类库，是程序中的默认类加载器。  
　　按照类的定义，两个类对象是否相同，负责加载它的类加载器实一个非常重要的条件，两个不同的类加载器加载同一个类文件所得到的类对象，是不相同的，不论是用equal，还是用instanceof。那这么多个类加载器，要怎么安排才能避开重复加载的问题呢？Java设计者推荐了双亲委派模型（Parents Delegation Model），除了启动类加载器作为最终选择之外，任何一个类加载器在加载类时都要经历以下3个过程：  
1. 从已加载类中寻找要加载的类。  
2. 第一步没找到，则交给自己的父加载器去加载。  
3. 第二步失败，则调用自己的findClass函数加载。  

　　如果开发者要自定义类加载器，一般情况下也要遵守这一套规则，保证系统中不会出现同名的类对象。  
　　那么能不能破坏双亲委派模型呢？比如上文中我们提到的热修复问题，如果B类使用系统类加载器来加载，想要在运行时替换肯定是不可能的，那么肯定要自定义类加载器来解决。如果系统中有很多个类都有类似的情况，而且他们分别属于不同的模块，最好的方案是每一个模块都有自己的类加载器，那么问题就出现了：当一个模块使用了另外一个模块中的类时，是交给父类加载器去加载呢，还是直接通知该模块的类加载器去加载呢？显然后者更合理。这是，加载流程就不是双亲委托模型了。所以，双亲委托模型并不是强制的，但是在加载java类库中的或者是全局相关的类时，必须要遵守双亲委托模型，否则一旦出现错误就会导致大面积的崩溃了。  

### 类加载器都要做些什么
　　类加载器主要工作有哪些呢？一般来说，类加载需要管理类对象的以下几个生命流程：   
1. 加载：将类从外部的数据流转换为内存方法区中的一个java.lang.Class对象。这一步具有巨大的自由度，最重要的一点是虚拟机没有规定外部数据流是什么样子的，所以理论上我们可以从任何一种文件格式、任何一种渠道（网络、文件、数据库）获得一个类，只要它能够被正确的解析。
2. 连接：连接包括以下三个步骤：验证、准备、解析，这一步是为了保证被加载的类能够被正确的时候而做的一系列操作。说到连接，我们会想到编译器执行的操作中也有类似的步骤，编译器中这一步主要是把函数名转换成一个相对寻址的地址，让函数与它的名称彻底脱离关系，有效缩短了程序运行过程中调用函数时所需要花费的时间。但是Java语言在编译过程中没有连接操作，要调用函数的方法，需要通过类加载器创建的类对象，找到对应的函数名，并根据函数名所指向的地址找到函数代码，然后开始执行。所以连接操作对于Java语言来说相当于C语言编译工作的下半场。
3. 初始化：这一步是给类中没有final限定符的static变量赋初值，这里所赋的初始是用户在代码中给变量所赋的值，如果用户没有指定，那么在连接阶段的准备步骤中，已经给这些变量赋了默认初值，数值类型赋0，引用类型赋null。
4. 使用：到这个阶段，类对象已经可以用来创建对象，也可以用来提供静态变量了。
5. 卸载：如果当前运行环境中已经没有任何关于这个类的引用，包括类实例和类静态变量引用，那么这个类就可以从内存中删除了。